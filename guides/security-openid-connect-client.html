<!DOCTYPE html>
<html>



<head>
  <title>Quarkus - Using OpenID Connect and OAuth2 Client and Filters to manage access tokens</title>
  <script id="adobe_dtm" src="https://www.redhat.com/dtm.js" type="text/javascript"></script>
  <script src="/assets/javascript/highlight.pack.js" type="text/javascript"></script>
  <META HTTP-EQUIV='Content-Security-Policy' CONTENT="default-src 'none'; script-src 'self' 'unsafe-eval' 'sha256-ANpuoVzuSex6VhqpYgsG25OHWVA1I+F6aGU04LoI+5s=' 'sha256-ipy9P/3rZZW06mTLAR0EnXvxSNcnfSDPLDuh3kzbB1w=' js.bizographics.com https://www.redhat.com assets.adobedtm.com jsonip.com https://ajax.googleapis.com https://www.googletagmanager.com https://www.google-analytics.com https://use.fontawesome.com; style-src 'self' https://fonts.googleapis.com https://use.fontawesome.com; img-src 'self' *; media-src 'self' ; frame-src https://www.googletagmanager.com https://www.youtube.com https://embed.restream.io https://app.mailjet.com; frame-ancestors 'none'; base-uri 'none'; object-src 'none'; form-action 'none'; font-src 'self' https://use.fontawesome.com https://fonts.gstatic.com;">
  <META HTTP-EQUIV='X-Frame-Options' CONTENT="DENY">
  <META HTTP-EQUIV='X-XSS-Protection' CONTENT="1; mode=block">
  <META HTTP-EQUIV='X-Content-Type-Options' CONTENT="nosniff">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Quarkus: Supersonic Subatomic Java">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@QuarkusIO"> 
  <meta name="twitter:creator" content="@QuarkusIO">
  <meta property="og:url" content="https://quarkus.io/guides/security-openid-connect-client" />
  <meta property="og:title" content="Quarkus - Using OpenID Connect and OAuth2 Client and Filters to manage access tokens" />
  <meta property="og:description" content="Quarkus: Supersonic Subatomic Java" />
  <meta property="og:image" content="https://quarkus.io/assets/images/quarkus_card.png" />
  
  <link rel="canonical" href="https://quarkus.io/guides/security-openid-connect-client">
  <link rel="shortcut icon" type="image/png" href="/favicon.ico" >
  <link rel="stylesheet" href="/guides/stylesheet/config.css" />
  <link rel="stylesheet" href="/assets/css/main.css" />
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml"  href="/feed.xml" title="Quarkus">
  <script src="/assets/javascript/goan.js" type="text/javascript"></script>
  <script src="/assets/javascript/hl.js" type="text/javascript"></script>
</head>

<body class="guides">
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJWS5L"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

  <div class="nav-wrapper">
  <div class="grid-wrapper">
    <div class="width-12-12">
      <input type="checkbox" id="checkbox" />
      <nav id="main-nav" class="main-nav">
  <div class="container">
    <div class="logo-wrapper">
      
        <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_600px_reverse.png" class="project-logo" title="Quarkus"></a>
      
    </div>
    <label class="nav-toggle" for="checkbox">
      <i class="fa fa-bars"></i>
    </label>
    <div id="menu" class="menu">
      <span>
        <a href="/get-started/" class="">Get Started</a>
      </span>
      <span>
        <a href="/guides/" class="active">Guides</a>
      </span>
      <span>
        <a href="/community/" class="">Community</a>
      </span>
      <span>
        <a href="/support/" class="">Support</a>
      </span>
      <span>
        <a href="/blog/" class="">Blog</a>
      </span>
      <span>
        <a href="https://code.quarkus.io" class="button-cta secondary white">Start Coding</a>
      </span>
    </div>
  </div>
      </nav>
    </div>
  </div>
</div>

  <div class="content">
    


<div class="grid-wrapper guide">
  <div class="grid__item width-10-12 width-12-12-mobile">
    <h1 class="text-caps">Quarkus - Using OpenID Connect and OAuth2 Client and Filters to manage access tokens </h1>
  </div>
  <div class="grid__item width-2-12 align-self-center text-right hide-mobile">
    <select id="guides-version-dropdown">
      
        
        
        
        
          <option value="main" >Main - SNAPSHOT</option>
        
      
        
        
        
        
          <option value="latest" selected>1.13 - Latest</option>
        
      
        
        
        
        
          <option value="1.11" >1.11</option>
        
      
        
        
        
        
      
    </select>
  </div>
  <div class="width-12-12">
    <div class="hide-mobile toc"><ul class="sectlevel1">
<li><a href="#oidcclient">OidcClient</a>
<ul class="sectlevel2">
<li><a href="#use-oidcclient-directly">Use OidcClient directly</a></li>
<li><a href="#use-oidcclient-in-microprofile-restclient-client-filter">Use OidcClient in MicroProfile RestClient client filter</a></li>
<li><a href="#use-injected-tokens">Use injected Tokens</a></li>
<li><a href="#refreshing-access-tokens">Refreshing Access Tokens</a></li>
<li><a href="#oidcclients">OidcClients</a></li>
<li><a href="#oidc-client-authentication">OidcClient Authentication</a></li>
<li><a href="#integration-testing-oidc-client">Testing</a></li>
</ul>
</li>
<li><a href="#token-endpoint-configuration">Token endpoint configuration</a></li>
<li><a href="#token-propagation">Token Propagation in MicroProfile RestClient client filter</a>
<ul class="sectlevel2">
<li><a href="#accesstokenrequestfilter">AccessTokenRequestFilter</a></li>
<li><a href="#jsonwebtokenrequestfilter">JsonWebTokenRequestFilter</a></li>
<li><a href="#integration-testing-token-propagation">Testing</a></li>
</ul>
</li>
<li><a href="#references">References</a></li>
</ul></div>
    <div>
      <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This guide explains how to use:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quarkus-oidc-client</code> and <code>quarkus-oidc-client-filter</code> extensions to acquire and refresh access tokens from OpenId Connect and OAuth 2.0 compliant Authorization Servers such as <a href="https://www.keycloak.org/about.html">Keycloak</a></p>
</li>
<li>
<p><code>quarkus-oidc-token-propagation</code> extension to propagate the current bearer or authorization code flow access tokens</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The access tokens managed by these extensions can be used as HTTP Authorization Bearer tokens to access the remote services.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="oidcclient"><a class="anchor" href="#oidcclient"></a>OidcClient</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>quarkus-oidc-client</code> extension provides a reactive <code>io.quarkus.oidc.client.OidcClient</code> which can be used to acquire and refresh tokens using SmallRye Mutiny <code>Uni</code> and <code>Vert.x WebClient</code>.</p>
</div>
<div class="paragraph">
<p><code>OidcClient</code> is initialized at the build time with the IDP token endpoint URL which can be auto-discovered or manually configured and uses this endpoint to acquire access tokens using <code>client_credentials</code> or <code>password</code> token grants and refresh the tokens using <code>refresh_token</code> grant.</p>
</div>
<div class="paragraph">
<p>Here is how <code>OidcClient</code> can be configured to use the <code>client_credentials</code> grant:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="properties" class="language-properties hljs">quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.secret=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>client_credentials</code> grant allows to set extra parameters to the token request via <code>quarkus.oidc-client.grant-options.client.&lt;param-name&gt;=&lt;value&gt;</code>. Here is how to set the intended token recipient via the <code>audience</code> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="properties" class="language-properties hljs">quarkus.oidc-client.grant-options.client.audience=https://example.com/api</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is how <code>OidcClient</code> can be configured to use the <code>password</code> grant:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="properties" class="language-properties hljs">quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.secret=secret
quarkus.oidc-client.grant.type=password
quarkus.oidc-client.grant-options.password.username=alice
quarkus.oidc-client.grant-options.password.password=alice</code></pre>
</div>
</div>
<div class="paragraph">
<p>In both cases <code>OidcClient</code> will auto-discover the token endpoint URL and use it to acquire the tokens.</p>
</div>
<div class="sect2">
<h3 id="use-oidcclient-directly"><a class="anchor" href="#use-oidcclient-directly"></a>Use OidcClient directly</h3>
<div class="paragraph">
<p>One can use <code>OidcClient</code> directly as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import javax.inject.PostConstruct;
import javax.inject.Inject;
import javax.ws.rs.GET;

import io.quarkus.oidc.client.OidcClient;
import io.quarkus.oidc.client.Tokens;

@Path("/service")
public class OidcClientResource {

    @Inject
    OidcClient client;

    volatile Tokens currentTokens;

    @PostConstruct
    public init() {
        currentTokens = client.getTokens().await().indefinitely();
    }

    @GET
    public String getResponse() {

        Tokens tokens = currentTokens;
        if (tokens.isAccessTokenExpired()) {
            // Add @Blocking method annotation if this code is used with Reactive RestClient
            tokens = client.refreshTokens(tokens.getRefreshToken()).await().indefinitely();
            currentTokens = tokens;
        }
        // use tokens.getAccessToken() to configure MP RestClient Authorization header/etc
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="use-oidcclient-in-microprofile-restclient-client-filter"><a class="anchor" href="#use-oidcclient-in-microprofile-restclient-client-filter"></a>Use OidcClient in MicroProfile RestClient client filter</h3>
<div class="paragraph">
<p><code>quarkus-oidc-client-filter</code> extension provides <code>io.quarkus.oidc.client.filter.OidcClientRequestFilter</code> JAX-RS ClientRequestFilter which uses <code>OidcClient</code> to acquire the access token, refresh it if needed, and set it as an HTTP <code>Authorization</code> <code>Bearer</code> scheme value.</p>
</div>
<div class="paragraph">
<p>By default, this filter will get <code>OidcClient</code> to acquire the first pair of access and refresh tokens at its initialization time. If the access tokens are short-lived and refresh tokens are not available then the token acquisition should be delayed with <code>quarkus.oidc-client.early-tokens-acquisition=false</code>.</p>
</div>
<div class="paragraph">
<p>You can selectively register <code>OidcClientRequestFilter</code> by using either <code>io.quarkus.oidc.client.filter.OidcClientFilter</code> or <code>org.eclipse.microprofile.rest.client.annotation.RegisterProvider</code> annotations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import io.quarkus.oidc.client.filter.OidcClientFilter;

@RegisterRestClient
@OidcClientFilter
@Path("/")
public interface ProtectedResourceService {

    @GET
    String getUserName();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.eclipse.microprofile.rest.client.annotation.RegisterProvider;
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import io.quarkus.oidc.client.filter.OidcClientRequestFilter;

@RegisterRestClient
@RegisterProvider(OidcClientRequestFilter.class)
@Path("/")
public interface ProtectedResourceService {

    @GET
    String getUserName();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, <code>OidcClientRequestFilter</code> can be registered automatically with all MP Rest or JAX-RS clients if <code>quarkus.oidc-client-filter.register-filter=true</code> property is set.</p>
</div>
</div>
<div class="sect2">
<h3 id="use-injected-tokens"><a class="anchor" href="#use-injected-tokens"></a>Use injected Tokens</h3>
<div class="paragraph">
<p>If you prefer you can use your own custom filter and inject <code>Tokens</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Provider
@Priority(Priorities.AUTHENTICATION)
public class OidcClientRequestCustomFilter implements ClientRequestFilter {

    @Inject
    Tokens tokens;

    @Override
    public void filter(ClientRequestContext requestContext) throws IOException {
        requestContext.getHeaders().add(HttpHeaders.AUTHORIZATION, "Bearer " + tokens.getAccessToken());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Tokens</code> producer will acquire and refresh the tokens, and the custom filter will decide how and when to use the token.</p>
</div>
<div class="paragraph">
<p>See also the previous section about delaying the token acquisition in some cases.</p>
</div>
</div>
<div class="sect2">
<h3 id="refreshing-access-tokens"><a class="anchor" href="#refreshing-access-tokens"></a>Refreshing Access Tokens</h3>
<div class="paragraph">
<p>Both <code>OidcClientRequestFilter</code> and <code>Tokens</code> producer will refresh the current expired access token if the refresh token is available.
Additionally, <code>quarkus.oidc-client.refresh-token-time-skew</code> property can be used for a preemptive access token refreshment to avoid sending nearly expired access tokens which may cause HTTP 401 errors. For example if this property is set to <code>3S</code> and the access token will expire in less than 3 seconds then this token will be auto-refreshed.</p>
</div>
<div class="paragraph">
<p>If the access token needs to be refreshed but no refresh token is available then an attempt will be made to acquire a new token using the configured grant such as <code>client_credentials</code>.</p>
</div>
<div class="paragraph">
<p>Please note that some OpenId Connect Providers will not return a refresh token in a <code>client_credentials</code> grant response. For example, starting from Keycloak 12 a refresh token will not be returned by default for <code>client_credentials</code>. The providers may also restrict a number of times a refresh token can be used.</p>
</div>
</div>
<div class="sect2">
<h3 id="oidcclients"><a class="anchor" href="#oidcclients"></a>OidcClients</h3>
<div class="paragraph">
<p><code>io.quarkus.oidc.client.OidcClients</code> is a container of <code>OidcClient`s - it includes a default `OidcClient</code> (which can also be injected directly as described above) and named clients which can be configured like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="properties" class="language-properties hljs">quarkus.oidc-client.client-enabled=false

quarkus.oidc-client.jwt-secret.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.jwt-secret.client-id=quarkus-app
quarkus.oidc-client.jwt-secret.credentials.jwt.secret=AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note in this case the default client is disabled with a <code>client-enabled=false</code> property. The <code>jwt-secret</code> client can be accessed like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

import io.quarkus.oidc.client.OidcClient;
import io.quarkus.oidc.client.OidcClients;

@Path("/clients")
public class OidcClientResource {

    @Inject
    OidcClients clients;

    @GET
    public String getResponse() {
        OidcClient client = clients.getClient("jwt-secret");
        // use this client to get the token
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you also use <a href="security-openid-connect-multitenancy">OIDC multitenancy</a> and each OIDC tenant has its own associated <code>OidcClient</code> then you can use a Vert.x <code>RoutingContext</code> <code>tenantId</code> attribute, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

import io.quarkus.oidc.client.OidcClient;
import io.quarkus.oidc.client.OidcClients;
import io.vertx.ext.web.RoutingContext;

@Path("/clients")
public class OidcClientResource {

    @Inject
    OidcClients clients;
    @Inject
    RoutingContext context;

    @GET
    public String getResponse() {
        String tenantId = context.get("tenantId");
        // named OIDC tenant and client configurations use the same key:
        OidcClient client = clients.getClient(tenantId);
        // use this client to get the token
    }
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you need you can also create new <code>OidcClient</code> programmatically like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

import io.quarkus.oidc.client.OidcClient;
import io.quarkus.oidc.client.OidcClients;
import io.quarkus.oidc.client.OidcClientConfig;

import io.smallrye.mutiny.Uni;

@Path("/clients")
public class OidcClientResource {

    @Inject
    OidcClients clients;

    @GET
    public String getResponse() {
        OidcClientConfig cfg = new OidcClientConfig();
        cfg.setId("myclient");
        cfg.setAuthServerUrl("http://localhost:8081/auth/realms/quarkus/");
        cfg.setClientId("quarkus");
        cfg.getCredentials().setSecret("secret");
        Uni&lt;OidcClient&gt; client = clients.newClient(config);
        // use this client to get the token
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oidc-client-authentication"><a class="anchor" href="#oidc-client-authentication"></a>OidcClient Authentication</h3>
<div class="paragraph">
<p><code>OidcClient</code> has to authenticate to the OpenId Connect Provider for the <code>client_credentials</code> and other grant requests to succeed.
All the <a href="https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication">OIDC Client Authentication</a> options are supported, for example:</p>
</div>
<div class="paragraph">
<p><code>client_secret_basic</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="properties" class="language-properties hljs">quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.secret=mysecret</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>client_secret_post</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="properties" class="language-properties hljs">quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.client-secret.value=mysecret
quarkus.oidc-client.credentials.client-secret.method=post</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>client_secret_jwt</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="properties" class="language-properties hljs">quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.jwt.secret=AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>private_key_jwt</code> with the PEM key file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="properties" class="language-properties hljs">quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.jwt.key-file=privateKey.pem</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>private_key_jwt</code> with the key store file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="properties" class="language-properties hljs">quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus/
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.jwt.key-store-file=keystore.jks
quarkus.oidc-client.credentials.jwt.key-store-password=mypassword
quarkus.oidc-client.credentials.jwt.key-password=mykeypassword
quarkus.oidc-client.credentials.jwt.key-id=mykey</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>private_key_jwt</code> or <code>private_key_jwt</code> authentication methods ensures that no client secret goes over the wire.</p>
</div>
</div>
<div class="sect2">
<h3 id="integration-testing-oidc-client"><a class="anchor" href="#integration-testing-oidc-client"></a>Testing</h3>
<div class="paragraph">
<p>Add the following dependencies to your test project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-junit5&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.tomakehurst&lt;/groupId&gt;
    &lt;artifactId&gt;wiremock-jre8&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;
    &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.awaitility&lt;/groupId&gt;
    &lt;artifactId&gt;awaitility&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Write Wiremock based <code>QuarkusTestResourceLifecycleManager</code>, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package io.quarkus.it.keycloak;

import static com.github.tomakehurst.wiremock.client.WireMock.matching;
import static com.github.tomakehurst.wiremock.core.WireMockConfiguration.wireMockConfig;

import java.util.HashMap;
import java.util.Map;

import com.github.tomakehurst.wiremock.WireMockServer;
import com.github.tomakehurst.wiremock.client.WireMock;
import com.github.tomakehurst.wiremock.core.Options.ChunkedEncodingPolicy;

import io.quarkus.test.common.QuarkusTestResourceLifecycleManager;

public class KeycloakRealmResourceManager implements QuarkusTestResourceLifecycleManager {

    private WireMockServer server;

    @Override
    public Map&lt;String, String&gt; start() {

        server = new WireMockServer(wireMockConfig().dynamicPort().useChunkedTransferEncoding(ChunkedEncodingPolicy.NEVER));
        server.start();

        server.stubFor(WireMock.post("/tokens")
                .withRequestBody(matching("grant_type=password&amp;username=alice&amp;password=alice"))
                .willReturn(WireMock
                        .aResponse()
                        .withHeader("Content-Type", "application/json")
                        .withBody(
                                "{\"access_token\":\"access_token_1\", \"expires_in\":4, \"refresh_token\":\"refresh_token_1\"}")));
        server.stubFor(WireMock.post("/tokens")
                .withRequestBody(matching("grant_type=refresh_token&amp;refresh_token=refresh_token_1"))
                .willReturn(WireMock
                        .aResponse()
                        .withHeader("Content-Type", "application/json")
                        .withBody(
                                "{\"access_token\":\"access_token_2\", \"expires_in\":4, \"refresh_token\":\"refresh_token_1\"}")));


        Map&lt;String, String&gt; conf = new HashMap&lt;&gt;();
        conf.put("quarkus.oidc-client.auth-server-url", server.baseUrl());
        conf.put("keycloak-url", server.baseUrl());
        return conf;
    }

    @Override
    public synchronized void stop() {
        if (server != null) {
            server.stop();
            server = null;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Prepare the REST test endpoints, you can have the test frontend endpoint which uses the injected MP REST client with a registered OidcClient filter to invoke on the downstream endpoint which echoes the token back, for example, see the <code>integration-tests/oidc-client-wiremock</code> in the <code>main</code> Quarkus repository.</p>
</div>
<div class="paragraph">
<p>Set <code>application.properties</code>, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="properties" class="language-properties hljs"># Use 'keycloak.url' property set by the test KeycloakRealmResourceManager
quarkus.oidc-client.auth-server-url=${keycloak.url}
quarkus.oidc-client.discovery-enabled=false
quarkus.oidc-client.token-path=/tokens
quarkus.oidc-client.client-id=quarkus-app
quarkus.oidc-client.credentials.secret=secret
quarkus.oidc-client.grant.type=password
quarkus.oidc-client.grant-options.password.username=alice
quarkus.oidc-client.grant-options.password.password=alice</code></pre>
</div>
</div>
<div class="paragraph">
<p>and finally write the test code. Given the Wiremock-based resource above, the first test invocation should return <code>access_token_1</code> access token which will expire in 4 seconds. Use <code>awaitility</code> to wait for about 5 seconds, and now the next test invocation should return <code>access_token_2</code> access token which confirms the expired <code>access_token_1</code> access token has been refreshed.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="token-endpoint-configuration"><a class="anchor" href="#token-endpoint-configuration"></a>Token endpoint configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default the token endpoint address is discovered by adding a <code>/.well-known/openid-configuration</code> path to the configured <code>quarkus.oidc-client.auth-server-url</code>.</p>
</div>
<div class="paragraph">
<p>Alternatively, if the discovery endpoint is not available or you would like to save on the discovery endpoint roundtrip, you can disable the discovery and configure the token endpoint address with a relative path value, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="properties" class="language-properties hljs">quarkus.oidc-client.auth-server-url=http://localhost:8180/auth/realms/quarkus
quarkus.oidc-client.discovery-enabled=false
# Token endpoint: http://localhost:8180/auth/realms/quarkus/protocol/openid-connect/tokens
quarkus.oidc-client.token-path=/protocol/openid-connect/tokens</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="token-propagation"><a class="anchor" href="#token-propagation"></a>Token Propagation in MicroProfile RestClient client filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>quarkus-oidc-token-propagation</code> extension provide <code>io.quarkus.oidc.token.propagation.AccessTokenRequestFilter</code> and <code>io.quarkus.oidc.token.propagation.JsonWebTokenRequestFilter</code> JAX-RS ClientRequestFilters which propagates the current <a href="security-openid-connect">Bearer</a> or <a href="security-openid-connect-web-authentication">Authorization Code Flow</a> access token as an HTTP <code>Authorization</code> <code>Bearer</code> scheme value.</p>
</div>
<div class="sect2">
<h3 id="accesstokenrequestfilter"><a class="anchor" href="#accesstokenrequestfilter"></a>AccessTokenRequestFilter</h3>
<div class="paragraph">
<p><code>AccessTokenRequestFilter</code> treats all tokens as Strings and as such it can work with both JWT and opaque tokens.</p>
</div>
<div class="paragraph">
<p>When you need to propagate the current Authorization Code Flow access token then <code>AccessTokenRequestFilter</code> will be the best option as such tokens do not need to be exchanged or otherwise re-enhanced. Authorization Code Flow access tokens may be also be opaque/binary tokens.</p>
</div>
<div class="paragraph">
<p>You can selectively register <code>AccessTokenRequestFilter</code> by using either <code>io.quarkus.oidc.token.propagation.AccessToken</code> or <code>org.eclipse.microprofile.rest.client.annotation.RegisterProvider</code>, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import io.quarkus.oidc.token.propagation.AccessToken;

@RegisterRestClient
@AccessToken
@Path("/")
public interface ProtectedResourceService {

    @GET
    String getUserName();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.eclipse.microprofile.rest.client.annotation.RegisterProvider;
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import io.quarkus.oidc.token.propagation.AccessTokenRequestFilter;

@RegisterRestClient
@RegisterProvider(AccessTokenRequestFilter.class)
@Path("/")
public interface ProtectedResourceService {

    @GET
    String getUserName();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, <code>AccessTokenRequestFilter</code> can be registered automatically with all MP Rest or JAX-RS clients if <code>quarkus.oidc-token-propagation.register-filter</code> property is set to <code>true</code> and <code>quarkus.oidc-token-propagation.json-web-token</code> property is set to <code>false</code> (which is a default value).</p>
</div>
<div class="paragraph">
<p>This filter will be additionally enhanced in the future to support exchanging the access tokens before propagating them.</p>
</div>
</div>
<div class="sect2">
<h3 id="jsonwebtokenrequestfilter"><a class="anchor" href="#jsonwebtokenrequestfilter"></a>JsonWebTokenRequestFilter</h3>
<div class="paragraph">
<p>Using <code>JsonWebTokenRequestFilter</code> is recommended if you work with Bearer JWT tokens where these tokens can have their claims such as <code>issuer</code> and <code>audience</code> modified and the updated tokens secured (for example, re-signed) again. It expects an injected <code>org.eclipse.microprofile.jwt.JsonWebToken</code> and therefore will not work with the opaque tokens.</p>
</div>
<div class="paragraph">
<p>Direct end to end Bearer token propagation should be avoided if possible. For example, <code>Client &#8594; Service A &#8594; Service B</code> where <code>Service B</code> receives a token sent by <code>Client</code> to <code>Service A</code>. In such cases <code>Service B</code> will not be able to distinguish if the token came from <code>Service A</code> or from <code>Client</code> directly. For <code>Service B</code> to verify the token came from <code>Service A</code> it should be able to assert a new issuer and audience claims.</p>
</div>
<div class="paragraph">
<p><code>JsonWebTokenRequestFilter</code> makes it easy for <code>Service A</code> implemementations to update the injected <code>org.eclipse.microprofile.jwt.JsonWebToken</code> with the new <code>issuer</code> and <code>audience</code> claim values and secure the updated token again with a new signature. The only difficult step is to ensure <code>Service A</code> has a signing key - it should be provisioned from a secure file system or from the remote secure storage such as Vault.</p>
</div>
<div class="paragraph">
<p>You can selectively register <code>JsonWebTokenRequestFilter</code> by using either <code>io.quarkus.oidc.token.propagation.JsonWebToken</code> or <code>org.eclipse.microprofile.rest.client.annotation.RegisterProvider</code>, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import io.quarkus.oidc.token.propagation.JsonWebToken;

@RegisterRestClient
@AccessToken
@Path("/")
public interface ProtectedResourceService {

    @GET
    String getUserName();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.eclipse.microprofile.rest.client.annotation.RegisterProvider;
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import io.quarkus.oidc.token.propagation.JsonWebTokenRequestFilter;

@RegisterRestClient
@RegisterProvider(JsonWebTokenTokenRequestFilter.class)
@Path("/")
public interface ProtectedResourceService {

    @GET
    String getUserName();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, <code>JsonWebTokenRequestFilter</code> can be registered automatically with all MP Rest or JAX-RS clients if both <code>quarkus.oidc-token-propagation.register-filter</code> and <code>`quarkus.oidc-token-propagation.json-web-token</code> properties are set to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>If this filter has to update the inject token and secure it with a new signature again then you can configure it like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="properties" class="language-properties hljs">quarkus.oidc-token-propagation.secure-json-web-token=true
smallrye.jwt.sign.key.location=/privateKey.pem
# Set a new issuer
smallrye.jwt.new-token.issuer=http://frontend-resource
# Set a new audience
smallrye.jwt.new-token.audience=http://downstream-resource
# Override the existing token issuer and audience claims if they are already set
smallrye.jwt.new-token.override-matching-claims=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>This filter will be additionally enhanced in the future to support exchanging the access tokens before propagating them.</p>
</div>
</div>
<div class="sect2">
<h3 id="integration-testing-token-propagation"><a class="anchor" href="#integration-testing-token-propagation"></a>Testing</h3>
<div class="paragraph">
<p>You can generate the tokens as described in <a href="security-openid-connect#integration-testing">OpenId Connect Bearer Token Integration testing</a> section.
Prepare the REST test endpoints, you can have the test frontend endpoint which uses the injected MP REST client with a registered token propagation filter to invoke on the downstream endpoint, for example, see the <code>integration-tests/oidc-token-propagation</code> in the <code>main</code> Quarkus repository.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references"><a class="anchor" href="#references"></a>References</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="security">Quarkus Security</a></p>
</li>
<li>
<p><a href="security-openid-connect">Quarkus - Using OpenID Connect to Protect Service Applications using Bearer Token Authorization</a></p>
</li>
<li>
<p><a href="security-openid-connect-web-authentication">Quarkus - Using OpenID Connect to Protect Web Applications using Authorization Code Flow</a></p>
</li>
</ul>
</div>
</div>
</div>
    </div>
  </div>
</div>

  </div>

  <div class="content project-footer">
  <div class="footer-section">
    <div class="logo-wrapper">
      <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_reverse.svg" class="project-logo" title="Quarkus"></a>
    </div>
  </div>
  <div class="grid-wrapper">
    <p class="grid__item width-3-12">Quarkus is open. All dependencies of this project are available under the <a href='https://www.apache.org/licenses/LICENSE-2.0' target='_blank'>Apache Software License 2.0</a> or compatible license.<br /><br />This website was built with <a href='https://jekyllrb.com/' target='_blank'>Jekyll</a>, is hosted on <a href='https://pages.github.com/' target='_blank'>Github Pages</a> and is completely open source. If you want to make it better, <a href='https://github.com/quarkusio/quarkusio.github.io' target='_blank'>fork the website</a> and show us what you’ve got.</p>

    
      <div class="width-1-12 project-links">
        <span>Navigation</span>
        <ul class="footer-links">
          
            <li><a href="/">Home</a></li>
          
            <li><a href="/guides">Guides</a></li>
          
            <li><a href="/community/#contributing">Contribute</a></li>
          
            <li><a href="/faq">FAQ</a></li>
          
            <li><a href="/get-started">Get Started</a></li>
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>Contribute</span>
        <ul class="footer-links">
          
            <li><a href="https://twitter.com/quarkusio">Follow us</a></li>
          
            <li><a href="https://github.com/quarkusio">GitHub</a></li>
          
            <li><a href="/security">Security&nbsp;policy</a></li>
          
        </ul>
      </div>
    
      <div class="width-2-12 project-links">
        <span>Get Help</span>
        <ul class="footer-links">
          
            <li><a href="https://stackoverflow.com/questions/tagged/quarkus">Stack Overflow</a></li>
          
            <li><a href="https://quarkusio.zulipchat.com">Chat room</a></li>
          
            <li><a href="https://groups.google.com/forum/#!forum/quarkus-dev">Development mailing list</a></li>
          
        </ul>
      </div>
    

    
      <div class="width-4-12 more-links">
        <span>Quarkus is made of community projects</span>
        <ul class="footer-links">
          
            <li><a href="https://vertx.io/" target="_blank">Eclipse Vert.x</a></li>
          
            <li><a href="https://smallrye.io" target="_blank">SmallRye</a></li>
          
            <li><a href="https://hibernate.org" target="_blank">Hibernate</a></li>
          
            <li><a href="https://netty.io" target="_blank">Netty</a></li>
          
            <li><a href="https://resteasy.github.io" target="_blank">RESTEasy</a></li>
          
            <li><a href="https://camel.apache.org" target="_blank">Apache Camel</a></li>
          
            <li><a href="https://microprofile.io" target="_blank">Eclipse MicroProfile</a></li>
          
            <li><a href="https://code.quarkus.io/" target="_blank">And many more...</a></li>
          
        </ul>
      </div>
    
  </div>
</div>

  <div class="content redhat-footer">
  <div class="grid-wrapper">
    <span class="licence">
      <i class="fab fa-creative-commons"></i><i class="fab fa-creative-commons-by"></i> <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">CC by 3.0</a> | <a href="https://www.redhat.com/en/about/privacy-policy">Privacy Policy</a>
    </span>
    <span class="redhat">
      Sponsored by
    </span>
    <span class="redhat-logo">
      <a href="https://www.redhat.com/" target="_blank"><img src="/assets/images/redhat_reversed.svg"></a>
    </span>
  </div>
</div>


  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>
  <script type="text/javascript" src="/assets/javascript/mobile-nav.js"></script>
  <script type="text/javascript" src="/assets/javascript/scroll-down.js"></script>
  <script src="/assets/javascript/satellite.js" type="text/javascript"></script>
  <script src="/guides/javascript/config.js" type="text/javascript"></script>
  <script src="/assets/javascript/search-filter.js" type="text/javascript"></script>
  <script src="/assets/javascript/guides-version-dropdown.js" type="text/javascript"></script>
  <script src="/assets/javascript/back-to-top.js" type="text/javascript"></script>
</body>

</html>
